---
theme: seriph
#theme: penguin
#theme: unicorn
#theme: light-icons
#background: 
#class: 'text-center'
#highlighter: prism
highlighter: shiki
lineNumbers: false
# some information about the slides, markdown enabled
info: |
  ## Slidev Starter Template
  Presentation slides for developers.

  Learn more at [Sli.dev](https://sli.dev)
---

# プログラムの数理

### ~ $Programma$ $\acute{e}$ $scritto$ $in$ $linguaggio$ $logica$ $matematica$ ~

<br><br>

## 渡辺伯陽

#### version: 0.2

---

# 導入部

唐突な問いから

### プログラミングによって実現できる例を挙げよ

コンピュータが普及した現代において、この問は自明である。<br>
実際、昨今何かしらのITシステムを構築するにあたって、どこかのレイヤーでプログラムを使うのは不可避であり、本質的な役割を果たしている、と言える。とりわけシステム開発においては、要求定義から出発して、それを何らかの設計ロジックに落としこみさえすれば、後はプログラミング作業に帰着する。

プログラムがこれだけ重要な地位を確立した理由は、例えば

* 曖昧性を排除した形式的言語による記述・形式化・再利用可能性
* 人間の抽象的な思考論理との親和性
* 少数の構文・記法で規定される仕組みや操作規則から生成される高い表現力と汎用性

などが考えられるが、いずれも、数学的構造・背景が見え隠れしている。
実際に、(型付き)プログラムの構造は、数学の証明構造と対応している事が古くから知られている。
(**Curry-Howard同型対応**)

このように、プログラムはかなり強力な概念・手段であり、高い汎用性と表現力をもつであろう、と期待される。

---

# プログラムの実現可能性に関するもう１つの問

可能性に基づく考察から不可能性に関する視点へ

一方で、先の問いの対となる、次の問いはどうであろうか？

### Q. プログラミングによって実現できない例は存在するか？
### もし存在するとしたら、具体的に述べよ。

この問も自然なものではあるが、実際にそのような例があったとして、実現不可能である事を証明する必要が出てくる。
しかしその事を証明するには、やや文脈(実現したい対象)が広すぎて、漠然としている。

なので、プログラムを「データを入力した際に、何かしらの出力結果を返すもの」として捉えてやると、
実現したい対象も、いわゆる(数学的な)「関数」と呼ばれるもので自ずと表現される。
すなわち、先の問いは

#### Q. (数学的な)関数をプログラムで表現できるか？

と言い換えられる。しかし、依然として数学的な視点からは、この「関数」の入出力が定義される範囲の情報が欠けている。そのため、この「関数」が指す対象をもう少し特定してやる必要がある。

※1. プログラミングで現れる関数とは異なり、純粋に数学的な対象としての「関数」である事に注意。以降、関数といえば、こちらを指す。

---

ここでは、以下に述べるような「関数」を考察対象とする：

### 任意のbit列で表現可能なデータが、ある基準$P$("客観的に"表現可能なもの=命題)を満たすか否か、を判定する(=真偽値を返す)数学的な関数
<!-- enclose this statement with a box -->

以降のページでは、このような数学的な関数を念頭に置き、再び**プログラムで実現可能な関数**に焦点を向け、例を幾つか挙げていく。


---

ここで見ていく関数は、プログラムで実現可能であるため、(最後に述べる例を除き)pythonによる実装例も合わせて示す。

### Eg 1. 偶数判定

まずはシンプルな例から。

<div class="grid grid-cols-[35%,35%,30%] gap-4"><div>

* 入力：自然数<br>
その集合を$\mathbb{N}$と表す

</div><div>

* 基準$P$: 偶数である

</div><div>

</div></div>

```python
def f1(n: int) -> bool:
    return n % 2 == 0
```

<br>

### Eg 2. 正則条件判定

もう少しだけ数学に高尚な(?)問として、入力が行列のケースを考える。

<div class="grid grid-cols-[35%,35%,30%] gap-4"><div>

* 入力: 整数値$K \times K$行列<br>
<!-- その集合を$\rm Mat(\mathbb{Z},K)$と表す -->

</div><div>

* 基準$P$: (実数値)逆行列が存在する

</div><div>

</div></div>

```python
import numpy as np
def f2(matrix: SquareMatrix[int]) -> bool:
    return np.det(matrix) != 0
```

---

### Eg 3. 時系列相関判定

せっかくなので、データ分析ぽい例を次に挙げてみる。

<div class="grid grid-cols-[35%,35%,30%] gap-4"><div>

* 入力: 2つの離散値有限時系列データ

</div><div>

* 基準$P$: 0.5より大きな相関を示す

</div><div>

</div></div>

```python
from scipy import stats
def f3(seq1: np.ndarray, seq2: np.ndarray) -> bool:
    return stats.pearsonr(seq1, seq2)[0] > 0.5
```

<br>

### Eg 4. 回文判定

文字列もビット列で表現されるので入力可能。

<div class="grid grid-cols-[35%,35%,30%] gap-4"><div>

* 入力: 英文

</div><div>

* 基準$P$: 回文である

</div><div>

</div></div>

```python
def f4(text: str) -> bool:
    normalized_text = "".join(text.split())
    return normalized_text == normalized_text[::-1]
```


---

### Eg 5. 構文判定

文字列が入力できるのだから、プログラムを表現するスクリプトそのものも入力できる。

<div class="grid grid-cols-[35%,35%,30%] gap-4"><div>

* 入力: プログラム

</div><div>

* 基準$P$: 構文として正しい

</div><div>

</div></div>

この例は勿論、プログラミング言語依存ではあるが、各種コンパイラがこれに該当する。

<hr>
<br>

幾つか簡単な例を見てきたが、現実のシステムの大半は、このような単純な入出力関数を組み合わせて構築されており、やっぱり何でもできそうに思えてくる。
しかしあくまでプログラムで実現可能な関数例を列挙しただけで、不可能性については何も言及していない。

---

# 関数 vs プログラム

プログラムは可算集合、関数は非可算集合

時間の都合上、詳細な説明はここでは割愛するが、
実は集合論という数学の理論を通す事で、全ての関数をプログラムで実現するのは**不可能**である事が示される。$^{※1}$

ざっくりと言えば、
* プログラムは文字列、すなわちビット列で表現されるため、1,2,3,...と数えられる
    + 数学の言葉では、可算集合と呼ばれる自然数の集合と1対1に対応する

* 関数は、与えられたビット列に対し、True/Falseを割り当てるが、これは順番に数えられない対象である
    + 特に自然数0,1,2,3,...に対してTrue(1)またはFalse(0)を割り当てるケースを含み、順に結果を並べると、これは0,1の無限数列を与える。だが、このような無限数列は1から順に数える事ができない事が知られている。
    + これを0以上1未満の小数の2進展開だと見なせば、実数を与えるが(単射ではない)、これは非可算集合と呼ばれるクラスに属する。

<!--
    + 可算な集合(ビット列のなす集合)から${0,1}$(真偽値の整数表現)への写像であり、これは小数の2進展開(0以上1未満の実数の元)を与える(ただし単射ではない)
    + 自然な逆写像は構成可能なので、少なくとも実数以上の濃度をもつ
-->

※1. もっと言えば、**ほぼ全ての**関数は、プログラムで実現できない

---

# プログラムの限界

### Q. では、具体的にはどんな数学的関数に対して、それを表現・実現するようなプログラムを作れないだろうか？

<br>
<br>
<br>

### A. 次のような関数に対応するプログラムを書き下すのは困難である事が知られている：

<div class="grid grid-cols-[35%,50%,15%] gap-4"><div>

* 入力: プログラム(とその入力)

</div><div>

* 基準$P$: プログラムが有限時間で停止する

</div><div>

</div></div>

---

# 停止判定プログラムの存在から導かれる主張

停止判定プログラムは超優秀な数学者？

もし、そのような停止判定プログラムが仮に作れたとしよう。その時、何が起こるか、を考えてみる。

実は1つの"応用例"として、「全ての自然数/整数に対して、ある性質$Q$が満たされる」(ただし$Q$はプログラムで表現可能な任意の基準/命題)、といった自然数/整数に関する数学のあらゆる命題(未解決問題含む！)が解けてしまう、というものがある。
以降、この命題を$\Pi_Q$と表す事にする。

#### Eg. そのような数学的命題/予想の例

* Bertrand-Chebyshevの定理：全ての自然数$n$に対し、$n < p \le 2n$を満たす素数$p$が存在する
    + $Q$は与えられた自然数に対して、「その数と2倍の数の間に必ず素数が存在する」という性質や命題に対応する
* Goldbach(ゴールドバッハ)予想: 全ての2よりも大きな偶数は2つの素数の和として表現可能である
    + $Q$は与えられた自然数に対して、「2倍して4足した数は、ある2つの素数の和に分解可能」という性質あるいは主張で、これはプログラムで表現可能
    + 論理式で表すと、$\forall n \in \mathbb{N}\; \exists p_1,p_2 \in {\rm Prime}_{\le 2n+2}\; 2n+4 = p_1 + p_2$、とかける
<!-- 0_ -->

<!-- ※あるいは、Collatz予想なども -->

この事について、もう少し説明する。

---

この停止判定プログラムの存在を仮定し、これを$\rm [Halt]$と表す。このプログラム$\rm [Halt]$は、入力として"任意のプログラム"を取り、「有限時間で入力プログラムが停止する」場合はTrue、そうでない場合はFalseを返す。
ここで、

<div class="grid grid-cols-[5%,95%] gap-4"><div>

<br><br>

$\rm [Q]=$

</div><div>

```python
def q(n: int) -> bool:
    return ...# 数学命題$\Pi_Q$の中に現れる自然数/整数に対する命題Qをプログラムで表現したもの

n = 0
while True:
    if not q(n):
        return False
    n += 1
```

</div></div>

というプログラムを入力してみる。（$\rm [Halt]([Q])$とかく）
もし先の数学的命題$\Pi_Q$が偽である(すなわち、ある自然数$n$に対して$q(n)$ = False)ならば、このプログラム$\rm [Q]$は有限時間で停止する。
よって、

* $\rm [Halt]([Q])$ = True である　$\Longleftrightarrow$　数学的命題・予想$\Pi_Q$が偽である
* $\rm [Halt]([Q])$ = Falseである $\Longleftrightarrow$　数学的命題・予想$\Pi_Q$が真である

が成立するため、
少なくとも、プログラム$\rm [Halt]$の構成をする難しさは、任意の自然数に関するある種の予想($\Pi_Q$とかけるもの)全てを解くレベルの難易度に匹敵する、と言える。

※なお兵庫県警は未解決問題を解けるレベルだという：[兵庫県警を使って停止性問題を解決する（というジョーク）](https://qiita.com/lie/items/dbc38167f78cb0faaf8a)

---

# 停止判定プログラムの実現不可能性に対する"証明"

いよいよ証明を試みる

まずは、次のようなプログラム$\rm [S]$を考えてみる：

<div class="grid grid-cols-[5%,95%] gap-4"><div>

<br><br>

$\rm [S]=$

</div><div>

```python
def F():
    s = open("...").read()# 自分自身をファイルとして開く
    if halt(s):# haltはプログラム[Halt]を関数として呼び出したもの
        while True: pass# 無限ループに入れば何でも良い
    else:
        return 0# 関数が停止すれば何でも良い

F()
```

</div></div>

ただし、プログラム$\rm [S]$内で$\rm [Halt]$を呼び出す関数をhalt、と表現した。
これは$\rm [Halt]([Q])$の出力結果と同じである。

以下、このプログラム$\rm [S]$が「停止する」または「非停止である」それぞれのケースを仮定してみて考察を進めてみる。

---

* ケース1: $\rm [S]$が停止する場合、すなわち、$\rm [Halt]([S])$ = Trueと仮定

この時、プログラム$\rm [S]$は

```python
def F():
    while True: pass

F()
```
と等価だが、明らかにこのプログラムは停止せず、仮定と矛盾するため、このケースは成立しえない。

* ケース2: $\rm [S]$が停止しない(所謂無限ループに陥る場合)場合、すなわち、$\rm [Halt]([S])$ = Falseと仮定

このケースでは、プログラム$\rm [S]$は

```python
def F():
    return 0

F()
```
と等価だが、明らかにこのプログラムは停止するため、このケースでも矛盾が発生し、成立しえない。

---

いずれのケースからも矛盾が導かれてしまったため、背理法より
元々「$\rm [Halt]$が存在する」と仮定した事が間違いであった事が分かる。

よって、任意のプログラムの停止判定を行えるプログラム$\rm [Halt]$は構成できない事がざっくり示された。(証明終)

<!-- * もう少し地に足がついた証明は、先の対角線論法を再び援用して行われる。 -->
<!-- * さらに厳密な数学的証明は、数学の言葉に翻訳して行われるが、... -->

<br><br>

以上の"証明"から、この停止判定関数こそが、プログラムで表現不可能な関数の例に他ならない。

* なお、このような関数は計算不可能または決定不能と呼ばれ、数学基礎論などでも顔を出す。
* 数学基礎論の中でも、$\rm G\"odel$の(第一)不完全性定理という有名な定理と関連している。

---

# プログラムで実現できない例はあった

<hr>

この"証明"のキモは、プログラム自身の能力が万能すぎて、自己参照・言及可能な事に起因している。
すなわち、プログラムは自分自身を入力に取れる事が重要な点である。
実際に、先の証明では、If文の評価式で参照している

このような現象は、論理学や哲学ではよく知られており、自己言及のパラドックスと呼ばれる。具体的には、例えば次のようなものが知られている：

* 嘘つきのパラドックス：「クレタ人は嘘つきである」とクレタ人が言う
* 全能のパラドックス：全能なる者は「(自身を含む)誰にも持ち上げられない石」を作れるか？
* Russellのパラドックス：$R = \{x \notin x \}$は定義可能か？
    + こちらは、現代の型理論・システムにつながり、結果として、プログラムの(型)安全性を保証するに至る


標語的に言うなれば、万能を目指して作られてしまったがために、プログラムは万能でない、と言える。

---

## 数理的志向はプログラミングの役に立たないのか？

これまでは数学・論理という武器を用いて、プログラムの限界を示してしまったが、$^{※1}$
逆にこの強力な武器を転用して、プログラムの"妥当性"を保証する、という応用に目を向けたい。
これらは「形式検証」あるいは「形式手法」という名前で研究・開発・実践がなされている。


※1. ただし、チューリングマシンを始めとする計算機の礎が誕生した背景として、まさに数学基礎論・論理学の発展があるため、今回の話の流れは歴史的順序とは逆である。

---

# 形式検証・形式手法

厳密な数学を用いたソフトウェア工学の一分野

* What: どんなもの？
    * 客観化・抽象化・記号化する事で、ソフトウェア開発における品質を高める事、あるいはその技術・手法の総称

* Why: 目的は？
    * 究極の目的：システムに"バグ"がない事を保証する = 品質保証
    * 実応用上の目的・目標：
        + 主観・曖昧性を排除した仕様(要件定義よりは具体化され、設計より抽象度が高い)を策定する
        + (開発上流工程において)仕様レベルの"バグ"を早期に発見する
        + システムの極一部に対して、正しい動作が行われる事を厳密に保証する

* How: 戦術は？
    * 数理論理学を始めとする数学言語で記述する
    * システムが取りうる状態の網羅的探索や、システムに要求される性質の証明実施

---

# 形式検証の3つのアプローチ

目的によって異なる手法・考え方が存在

先に3つの目的・目標を挙げたが、それぞれのアプローチに対し、およそ対応する名前がついている：

+ 形式仕様記述：主観・曖昧性を排除した仕様(要件定義よりは具体化され、設計より抽象度が高い)を策定する
+ モデル検査：(開発上流工程において)仕様レベルの"バグ"を早期に発見する
+ 定理証明：システムの極一部に対して、正しい動作が行われる事を厳密に保証する

もちろん、これらは相互に関わっており、このような切り分けが常にできるわけではない。
例えば、この枠内に当てはまらないが、形式手法の1種として考えられている概念として
『型推論』がある。
また、それぞれの用語が指す目的・目標は、人によって微妙に異なってもいる。
あくまでここでは、発表者の理解を記載している。

<!--
+ 対話型定理証明(証明支援)、自動定理証明
他にも、
* 
-->

また本来であれば、各手法を1つずつ説明していくのが望ましいが、かなりの時間と準備を要するため、本発表では詳細は割愛する。

---

# 時相論理

E-commerceでの利用例

その代わりにここでは、形式手法にてよく使われる数学的道具『時相論理』を用いて、仕様を表現する(非現実的な)一例を示す。
これは、馴染み深い"通常の論理学"(命題論理あるいは1階述語論理)に時間の概念を導入したものである。

以下に、あるE-commerceシステムの仕様を、時相論理の命題として表現した例を示す：

$$
\footnotesize
\begin{array}{c}
\forall A \in {\rm Customer}\;
\forall X \in {\rm Item}\;\;
\exists M_X \in {\rm Money}\;\;
\square \left[ ({\rm A\; orders\; X}) \rightarrow \lozenge ({\rm A\; pays\; M_x}) \wedge \lozenge ({\rm X\; is\; shipped\; to\; A}) \right]
\end{array}
$$

そして、これが意味する所は、
$$
\footnotesize
\begin{array}{c}
\underset{\substack{どの顧客Aに\\対しても}}{\forall A \in {\rm Customer}}\;
\underset{\substack{どの商品Xに\\対しても}}{\forall X \in {\rm Item}}\;
\underset{\substack{ある金額M_Xが\\存在して}}{\exists M_X \in {\rm Money}}\!\!
\stackrel{\substack{常に成立 \\ する事 \\ として}}{\square}\!\!
\left[
\underset{AがXを注文する}{({\rm A\; orders\; X})}\!
\stackrel{\substack{際には}}\rightarrow
\stackrel{いつかは}{\lozenge}\!
\underset{AがM_xを支払い}{({\rm A\; pays\; M_x})}
\stackrel{かつ}{\wedge}
\stackrel{いつかは}{\lozenge}\!
\underset{XがAへと発送される}{({\rm X\; is\; shipped\; to\; A})}
\right]
\end{array}
$$

となる。なお"通常の論理学"だと、顧客Aが商品Xを注文した時点では、AによるXの支払い(例えば振り込み)や、AへのXの発送は達成されていない事を表現できないが、システム的にはこのような中間状態が発生する。

ちなみに、この命題が破綻するケースとして、顧客による購入キャンセルした場合が考えられる。
幾つかのテストによって、このような命題が偽である状況が観測されると、それが仕様の不備としてそのまま検出される。

---

# 実際のシステムへの適用事例に関して

限られた公開事例

実は、形式検証・手法の応用事例は世界的に見てもそれほど多くない。その理由としては、

* 数学的素養のあるエキスパートを要するため、人的コストが高い
* 現代的な巨大システムそれ自体に対しては、膨大な計算が必要になってしまい、実質計算不可能

といった点が挙げられる。これらの問題を軽減するために、

* システム全体を数式化するのではなく、ある程度適切な抽象化を実施（計算コスト削減）
* 仕様を設計・策定しさえすれば、後は適切なツールが自動で計算・可視化（人的コスト削減）

といった工夫が行われている。とは言え、費用対効果やシステムの特性の観点から、現在までに適用が進んでいる範囲は以下のような性質・領域に限られている：

* 頻繁な更新やパッチ適用が難しく、比較的設計が小規模な組み込み系
* バグ等が引き起こしうる損害額や社会的影響が非常に大きい公的インフラやセキュリティ系
* 抽象化がしやすく、人による設計が難しい分散システム系

---

# 具体的な適用事例・対象

* 原子力発電所や航空管制
* 鉄道・車両
    + パリの無人地下鉄車両・プラットフォームド制御に関する仕様策定(開発工数の削減)
    + パリの地下鉄プラットフォームドア制御
    + シャルルドゴール空港の無人シャトル制御
    + 北京地下鉄の自動列車停止システム

* 組み込み
    + ICカード(電子パスポートアプリケーション)のセキュリティ認証確認
    + Felicaチップファームウェアにおける仕様策定

* 分散システム:  AWS DynamoDB

詳細はほとんど公開されていないが、とりわけ達成目標としては、
仕様の不整合を事前に取り除く事で、実装・テスト工数を削減し、バグの発生件数を抑える
というものが多い。

---

# データ分析への応用？

根本の考え方は異なるが...

形式手法は、論理学をベースにした演繹的アプローチである。
一方で、データ分析や機械学習は、現象・データをベースにした帰納的アプローチである。
よって、形式手法をデータ分析・機械学習に用いたり、あるいはその逆はどうしても筋が悪くなりがちである。$^{※1}$

ただし裏を返せば、相補的な関係ではあるからこそ、両者を直接または並列に用いるにあたってはその実現・応用可能性があると考えている。具体的には

* データマート等のテーブル設計において、設計や条件が適切か、を形式手法にて検証・精査する
    + 実際、モデル検査では、オブジェクト間の関係をモデル化し、可能な状態を網羅的に調査している
* 機械学習のモデル開発において、データでは捉えきれない、ドメイン知識ベースの補正を導入する際に、形式手法にて仕様策定や検査を行う
    + 例えばロボット制御では、可能な動き(物理システムの限界)や状態(例えばオーバヒートしないか)の検証を、モデル側で行うのは困難である

などが一例として考えられる。

※1. 今年のIBISでは、まさにこのテーマを扱ったセッションが存在したが、まだまだ発展途上のようである。

---

# 総括

お疲れ様です

プログラムが数理論理学を背景にしている事を示唆する、理論的な側面の重要な例として

* 停止性判定の実現不可能性

の証明含む概要を述べた。

また数理論理学との親和性の高さから、応用的な方向の重要な例として

* 形式検証・形式手法

のごく触りだけを紹介した。

---

# 参考文献：計算可能性・停止性判定

<hr>

* MacCormick (長尾訳) 『計算できるもの、計算できないもの　実践的アプローチによる計算理論入門』、Oreilly社 2020
* 高橋『計算論　計算可能性とラムダ計算』、近代科学社 1991
* Hopcroftm Motwani, Ullman（野崎・高橋・町田・山崎訳）『オートマトン　計算理論 計算論II』、サイエンス社 2003
* 鹿島『数理論理学　（現代基礎数学15）』、朝倉書店 2009
* 『コンピュータ・サイエンス基礎：計算可能性』 http://www.kurims.kyoto-u.ac.jp/~terui/cs2020.pdf
* 『情報数学　第5回 計算不可能な関数』 http://web.sfc.keio.ac.jp/~hagino/mi15/05-ppt.pdf
* 『決定不能問題　特にタイル張り問題』 https://fujidig.github.io/articles/201609-tilingproblem.pdf
* 『6．チューリングマシンの符号化と計算不可能性計算不可能性』 http://www.akita-pu.ac.jp/system/elect/ins/kusakari/japanese/teaching/InfoMath/2007/note/6.pdf
* 『兵庫県警を使って停止性問題を解決する（というジョーク）』https://qiita.com/lie/items/dbc38167f78cb0faaf8a
* "#47 As a computer science theorist, I want to thank Japanese polices" https://github.com/hamukazu/lets-get-arrested/issues/47

---

# 参考文献：形式検証・形式手法

<hr>

* 中島『形式手法入門　ロジックによるソフトウェア設計』、オーム社 2012
* 荒木・張『プログラム仕様記述論』、オーム社 2002
* Baier, Katoen, "Principles of Model Checking", MIT press 2008
* Jackson（今井・酒井・遠藤・片岡著）『抽象によるソフトウェア設計　Alloyではじめる形式手法』、オーム社 2011
* Wayne（株式会社クイープ監訳）『実践TLA+』、翔泳社 2021
* 小野『情報科学における論理』、日本評論社 1994
* 『JASA主催/IPA共催セミナー　形式手法適用事例の紹介』 https://www.ipa.go.jp/files/000005272.pdf
* 『ソフトウェア工学の道具としての形式手法　NII Technical Report』 https://www.nii.ac.jp/TechReports/public_html/07-007J.pdf
* 『モデル検査技術に基づくソフトウェア検証の概要』 http://www.selab.is.ritsumei.ac.jp/~ohnishi/RE/modelcheck.pdf
* 『理論計算機科学入門　有限と無限のあいだ』 http://group-mmm.org/~ichiro/talks/20191107NIIPublic.pdf
* 『SWETグループが考える形式手法の現在とこれからの可能性 - DeNA Testing Blog』 https://swet.dena.com/entry/2019/06/24/170000

---
layout: section

---

# Appendix

---

# プログラムのなす集合

プログラムは可算無限個存在

まず、先にも使った

* プログラムは有限個の文字から構成される文字列、すなわちビット列で表現可能である。

という事実を思い出そう。また

* ビット列は、1から順に数えることができる。
    * 具体的には0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111, 0000, ...となる。
    * 数学的には、$b_1 < b_2 \stackrel{\rm def}{\iff}$ 「($b_1$の長さ) < ($b_2$の長さ) 」または「ビット列としての長さが等しい 、かつ($b_1$が表現する自然数) < ($b_2$が表現する自然数)」、で定義される全順序構造と整合するものが一意に定まる。

という主張を踏まえると、有限文字列集合は、自然数の集合$\mathbb{N}$と1対1対応がつく。
よって、プログラムは$0,1,2,3,\ldots$と数えられる自然数の集合でナンバリングされる事が分かったので、以下、プログラムと対応する数字を同一視する。

* 注1. 今回はビット列経由で1対1対応をつけたが、所謂$\rm G\"odel$数と呼ばれる別の符号化による実現もよく使われる。
* 注2. 正確には、コンパイルが通らないプログラムを除外する必要があるが、結論は変わらない。

---

# 関数のなす集合

関数は非可算無限個存在

次に、ビット列から真偽値への関数全体がどのようなものか、について考察する。
これを数式で書くと、
* $f: \mathbb{N} \rightarrow \mathbb{B} := \{ \rm True, False \}$
と表現される。

そしてこのような関数$f$が与えられると、各自然数$n$に対して、0以上1未満の実数の2進数表示
$$
0.f_0f_1f_2f_3...
\quad
{\rm where}
\quad
f_n :=
\begin{cases}
1 \quad {\rm if}\;\; f(n) = {\rm True} \\
0 \quad {\rm if}\;\; f(n) = {\rm False}
\end{cases}
\;\; {\rm for} \;\; \forall n \in \mathbb{N}
$$
が定まる。すなわち、対応する実数値は$\displaystyle \sum_{n=0}^{\infty} \dfrac{f_n}{2^{n+1}}$で表せるが、これは単射性を保証しない。

逆に0以上1未満の実数に対し、2進数展開を考える事で、無限数列$f_0, f_1, f_2, \ldots$が得られ、これは関数$f$を定める。この対応は全射であり、上で考えた写像は逆写像となっている。

よって、このような関数のなす集合は、少なくとも実数の半区間$[0,1)$と1対1対応な部分集合を含む事が分かった。

---

ここまでの考察をまとめると、

* 「プログラム」のなす集合 = 自然数の集合$\mathbb{N}$
* 「関数」のなす集合 = 実数の半区間の集合$[0,1)$を含む（実は$[0,1)$と1対1）

である。

ここで仮に、関数からプログラムへの対応付けを行う事を考える。特に$[0,1)$と1対1な関数に制限する。
これは集合の言葉では、
実数半区間$[0,1)$から自然数$\mathbb{N}$への単射、さらに言えば1対1対応を構成する事に他ならない。

<hr>

実はこのような写像を構成する事は不可能である事が、Cantorの対角線論法と呼ばれる技巧を用いて示されている。

---

# 対角線論法(有限版)

簡単な例

* 設定: Aさん、Bさん、Cさん、Dさんの4人に、4つのYes/Noで答える質問を行い、その結果が以下であったとする。(4ではなく、一般にNに設定と主張は拡張可能)

<table>

<tr><td width="20%">
</td><td width="20%">
質問１
</td><td width="20%">
質問２
</td><td width="20%">
質問３
</td><td width="20%">
質問４
</td></tr>

<tr><td width="20%">
A
</td><td width="20%">
Yes
</td><td width="20%">
No
</td><td width="20%">
No
</td><td width="20%">
Yes
</td></tr>

<tr><td width="20%">
B
</td><td width="20%">
Yes
</td><td width="20%">
No
</td><td width="20%">
Yes
</td><td width="20%">
No
</td></tr>

<tr><td width="20%">
C
</td><td width="20%">
No
</td><td width="20%">
No
</td><td width="20%">
No
</td><td width="20%">
Yes
</td></tr>

<tr><td width="20%">
D
</td><td width="20%">
Yes
</td><td width="20%">
No
</td><td width="20%">
No
</td><td width="20%">
Yes
</td></tr>

</table>


* 主張: この時、この表の対角線の結果を取ってきて、否定したものを並べた時に、この回答した人物Xは存在しない：

<table>
<tr><td width="20%">
X
</td><td width="20%">
No
</td><td width="20%">
Yes
</td><td width="20%">
Yes
</td><td width="20%">
No
</td></tr>
</table>


---

# 背理法に基づく証明

証明). このような1対1対応が存在すると仮定する。特に$c : \mathbb{N} \rightarrow [0,1)$
を考え、2進数表示した小数を順番に並べていく。
特に$n$番目は$c(n)$で与えられる。

この時、先の議論を無限の長さに拡張して、

c(1) | 0.00101... <br>
c(2) | 0.01100... <br>
c(3) | 0.10111... <br> 
c(4) | 0.11001... <br>
c(5) | 0.10101... <br>
...<br>

なお、$k$番目の小数$c(k)$の小数第$\ell$桁目を$c(k)_\ell$<!-- 0_ -->
とおく。
この時、第$n$桁目が
$1-c(n)_n$<!-- 0_ -->
で与えられる2進数小数を考えると、これは並べられた小数のどれとも一致しない。
これは、$c$を用いて小数を順番に並べた、という仮定に矛盾する。

よって、「$\mathbb{N}$と$[0,1)$の間の1対1対応が存在」という最初の仮定は間違っており、この2つの集合間の1対1対応は構成できない。(終)

